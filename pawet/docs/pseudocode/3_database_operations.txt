================================================================================
                      DATABASE OPERATIONS PSEUDOCODE
                      PAWET-B Organizational Design System
================================================================================

This document provides detailed pseudocode for SQL database operations (CRUD)
using SQLite with JDBC, demonstrating database integration with OOP.

================================================================================
1. SQL INJECTION PREVENTION
================================================================================

SECURITY CONCEPT: Prepared Statements vs String Concatenation

VULNERABLE CODE (DON'T DO THIS):
┌────────────────────────────────────────────────────────────────────┐
│ FUNCTION searchEmployeeUnsafe(userId):                             │
│     sql ← "SELECT * FROM employees WHERE id = '" + userId + "'"   │
│     result ← statement.executeQuery(sql)                           │
│                                                                    │
│     // DANGER! If userId = "M001' OR '1'='1"                      │
│     // SQL becomes: SELECT * FROM employees WHERE id = 'M001'      │
│     //              OR '1'='1'                                     │
│     // This returns ALL employees! (SQL Injection Attack)          │
│ END FUNCTION                                                       │
└────────────────────────────────────────────────────────────────────┘

SECURE CODE (OUR IMPLEMENTATION):
┌────────────────────────────────────────────────────────────────────┐
│ FUNCTION searchEmployeeSafe(userId):                               │
│     sql ← "SELECT * FROM employees WHERE id = ?"                  │
│     pstmt ← connection.prepareStatement(sql)                       │
│     pstmt.setString(1, userId)  // Parameterized - treats as data │
│     result ← pstmt.executeQuery()                                  │
│                                                                    │
│     // SAFE! Even if userId = "M001' OR '1'='1"                   │
│     // PreparedStatement treats entire input as literal string    │
│     // Searches for employee with ID literally "M001' OR '1'='1"  │
│     // (won't find match, returns nothing - no injection!)        │
│ END FUNCTION                                                       │
└────────────────────────────────────────────────────────────────────┘

KEY BENEFITS:
• Prevents SQL injection attacks by treating user input as data, not code
• Automatically escapes special characters
• Better performance (prepared statements are precompiled)
• Industry best practice for database security

================================================================================
2. DATABASE INITIALIZATION
================================================================================

ALGORITHM: InitializeDatabase()

  PSEUDOCODE:

    FUNCTION DatabaseManager():
        TRY
            // Load SQLite JDBC driver
            Class.forName("org.sqlite.JDBC")

            // Establish connection
            connection ← DriverManager.getConnection("jdbc:sqlite:data/pawet.db")

            PRINT "✓ Database connection established"

            // Create tables if they don't exist
            CALL initializeTables()

        CATCH ClassNotFoundException
            PRINT "ERROR: SQLite JDBC driver not found"
            PRINT "Ensure sqlite-jdbc.jar is in classpath"

        CATCH SQLException
            PRINT "ERROR: Failed to connect to database"
        END TRY
    END FUNCTION

    FUNCTION initializeTables():
        statement ← connection.createStatement()

        // Create employees table
        sql ← "CREATE TABLE IF NOT EXISTS employees (
                  id TEXT PRIMARY KEY,
                  name TEXT NOT NULL,
                  email TEXT,
                  phone TEXT,
                  department_id TEXT,
                  role TEXT NOT NULL,
                  salary REAL,
                  hire_date TEXT,
                  role_type TEXT NOT NULL,
                  specialization TEXT,
                  team_list TEXT,
                  budget_authority REAL,
                  project_list TEXT,
                  equipment_list TEXT,
                  certifications TEXT,
                  FOREIGN KEY (department_id) REFERENCES departments(id)
               )"
        statement.execute(sql)

        // Similarly create departments, projects, equipment tables
        ...

        statement.close()
        PRINT "✓ Database tables initialized"
    END FUNCTION

  NOTES:
    - SQLite creates database file automatically if it doesn't exist
    - IF NOT EXISTS prevents errors on subsequent runs
    - Foreign keys enforce referential integrity

================================================================================
2. CREATE (INSERT) OPERATIONS
================================================================================

ALGORITHM: SaveEmployee(employee)

  INPUT:
    employee: Employee object (Manager, Scientist, or Technician)

  OUTPUT:
    void (inserts into database)

  PSEUDOCODE:

    FUNCTION saveEmployee(employee):
        sql ← "INSERT INTO employees (id, name, email, phone, department_id, " +
              "role, salary, hire_date, role_type, specialization, " +
              "team_list, budget_authority, project_list, equipment_list, " +
              "certifications) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

        TRY
            // Create prepared statement (prevents SQL injection)
            preparedStatement ← connection.prepareStatement(sql)

            // Set common fields (all employee types)
            preparedStatement.setString(1, employee.getId())
            preparedStatement.setString(2, employee.getName())
            preparedStatement.setString(3, employee.getEmail())
            preparedStatement.setString(4, employee.getPhone())
            preparedStatement.setString(5, employee.getDepartmentId())
            preparedStatement.setString(6, employee.getRole())
            preparedStatement.setDouble(7, employee.getSalary())
            preparedStatement.setString(8, employee.getHireDate().toString())
            preparedStatement.setString(9, employee.getRoleType())

            // Set type-specific fields (polymorphism)
            IF employee instanceof Scientist THEN
                scientist ← (Scientist) employee
                preparedStatement.setString(10, scientist.getSpecialization())
                preparedStatement.setString(11, null)
                preparedStatement.setDouble(12, 0)
                preparedStatement.setString(13, scientist.getProjectListAsString())
                preparedStatement.setString(14, null)
                preparedStatement.setString(15, null)

            ELSE IF employee instanceof Manager THEN
                manager ← (Manager) employee
                preparedStatement.setString(10, null)
                preparedStatement.setString(11, manager.getTeamListAsString())
                preparedStatement.setDouble(12, manager.getBudgetAuthority())
                preparedStatement.setString(13, null)
                preparedStatement.setString(14, null)
                preparedStatement.setString(15, null)

            ELSE IF employee instanceof Technician THEN
                technician ← (Technician) employee
                preparedStatement.setString(10, null)
                preparedStatement.setString(11, null)
                preparedStatement.setDouble(12, 0)
                preparedStatement.setString(13, null)
                preparedStatement.setString(14, technician.getEquipmentListAsString())
                preparedStatement.setString(15, technician.getCertifications())
            END IF

            // Execute INSERT
            preparedStatement.executeUpdate()

            preparedStatement.close()

        CATCH SQLException
            PRINT "ERROR: Failed to save employee " + employee.getId()
        END TRY
    END FUNCTION

  SECURITY FEATURES:
    - Prepared statements prevent SQL injection
    - Parameterized queries (? placeholders)
    - Type-safe value binding

  EXAMPLE SQL GENERATED:
    INSERT INTO employees (id, name, email, ..., role_type, specialization, ...)
    VALUES ('S001', 'Kofi Annan', 'kofi@pawet.org', ..., 'SCIENTIST', 'Marine Biology', ...)

================================================================================
3. READ (SELECT) OPERATIONS
================================================================================

ALGORITHM: LoadEmployees()

  OUTPUT:
    List<Employee> containing all employees from database

  PSEUDOCODE:

    FUNCTION loadEmployees():
        employees ← empty List
        sql ← "SELECT * FROM employees"

        TRY
            statement ← connection.createStatement()
            resultSet ← statement.executeQuery(sql)

            WHILE resultSet.hasNext() DO
                // Read common fields
                id ← resultSet.getString("id")
                name ← resultSet.getString("name")
                email ← resultSet.getString("email")
                phone ← resultSet.getString("phone")
                departmentId ← resultSet.getString("department_id")
                role ← resultSet.getString("role")
                salary ← resultSet.getDouble("salary")
                hireDate ← LocalDate.parse(resultSet.getString("hire_date"))
                roleType ← resultSet.getString("role_type")

                employee ← null

                // Create appropriate subclass (polymorphism)
                IF roleType EQUALS "MANAGER" THEN
                    teamList ← resultSet.getString("team_list")
                    budgetAuthority ← resultSet.getDouble("budget_authority")

                    employee ← new Manager(id, name, email, phone, departmentId,
                                          role, salary, hireDate,
                                          parseTeamList(teamList), budgetAuthority)

                ELSE IF roleType EQUALS "SCIENTIST" THEN
                    specialization ← resultSet.getString("specialization")
                    projectList ← resultSet.getString("project_list")

                    employee ← new Scientist(id, name, email, phone, departmentId,
                                            role, salary, hireDate, specialization,
                                            parseProjectList(projectList))

                ELSE IF roleType EQUALS "TECHNICIAN" THEN
                    equipmentList ← resultSet.getString("equipment_list")
                    certifications ← resultSet.getString("certifications")

                    employee ← new Technician(id, name, email, phone, departmentId,
                                             role, salary, hireDate,
                                             parseEquipmentList(equipmentList),
                                             certifications)
                END IF

                IF employee IS NOT null THEN
                    employees.add(employee)
                END IF
            END WHILE

            resultSet.close()
            statement.close()

        CATCH SQLException
            PRINT "ERROR: Failed to load employees"
        END TRY

        RETURN employees
    END FUNCTION

  COMPLEXITY:
    Time: O(n) where n = number of records
    Space: O(n) stores all records in memory

  OBJECT-RELATIONAL MAPPING (ORM):
    - Database row → Java object
    - Flat table → Object hierarchy
    - SQL types → Java types (TEXT→String, REAL→double, etc.)

================================================================================
4. UPDATE OPERATIONS
================================================================================

ALGORITHM: UpdateEmployee(employee)

  INPUT:
    employee: Employee object with updated fields

  PSEUDOCODE:

    FUNCTION updateEmployee(employee):
        // Simple approach: Delete old record, insert new one
        CALL deleteEmployee(employee.getId())
        CALL saveEmployee(employee)
    END FUNCTION

  ALTERNATIVE (Direct UPDATE):

    FUNCTION updateEmployeeDirect(employee):
        sql ← "UPDATE employees SET name=?, email=?, phone=?, " +
              "department_id=?, role=?, salary=?, ... WHERE id=?"

        TRY
            preparedStatement ← connection.prepareStatement(sql)

            // Set all fields (similar to saveEmployee)
            preparedStatement.setString(1, employee.getName())
            preparedStatement.setString(2, employee.getEmail())
            ...
            preparedStatement.setString(15, employee.getId())  // WHERE clause

            rowsAffected ← preparedStatement.executeUpdate()

            IF rowsAffected == 0 THEN
                PRINT "WARNING: No employee found with ID " + employee.getId()
            END IF

            preparedStatement.close()

        CATCH SQLException
            PRINT "ERROR: Failed to update employee"
        END TRY
    END FUNCTION

  EXAMPLE SQL:
    UPDATE employees
    SET name='Alice Mbeki', email='alice.new@pawet.org', salary=90000, ...
    WHERE id='M001'

================================================================================
5. DELETE OPERATIONS
================================================================================

ALGORITHM: DeleteEmployee(employeeId)

  INPUT:
    employeeId: String ID of employee to delete

  PSEUDOCODE:

    FUNCTION deleteEmployee(employeeId):
        sql ← "DELETE FROM employees WHERE id = ?"

        TRY
            preparedStatement ← connection.prepareStatement(sql)
            preparedStatement.setString(1, employeeId)

            rowsAffected ← preparedStatement.executeUpdate()

            IF rowsAffected > 0 THEN
                PRINT "✓ Employee deleted: " + employeeId
            ELSE
                PRINT "⚠ No employee found with ID: " + employeeId
            END IF

            preparedStatement.close()

        CATCH SQLException
            PRINT "ERROR: Failed to delete employee " + employeeId
        END TRY
    END FUNCTION

  EXAMPLE SQL:
    DELETE FROM employees WHERE id='M001'

  CASCADING DELETES:
    - When deleting employee, also update:
      - Department employee_count
      - Projects led by this employee
      - Equipment assigned to this employee
      - Team lists containing this employee

================================================================================
6. DEPARTMENT CRUD OPERATIONS
================================================================================

SAVE DEPARTMENT:

    FUNCTION saveDepartment(department):
        sql ← "INSERT OR REPLACE INTO departments " +
              "(id, name, region, budget, manager_id, employee_count) " +
              "VALUES (?, ?, ?, ?, ?, ?)"

        preparedStatement ← connection.prepareStatement(sql)
        preparedStatement.setString(1, department.getId())
        preparedStatement.setString(2, department.getName())
        preparedStatement.setString(3, department.getRegion())
        preparedStatement.setDouble(4, department.getBudget())
        preparedStatement.setString(5, department.getManagerId())
        preparedStatement.setInt(6, department.getEmployeeCount())

        preparedStatement.executeUpdate()
        preparedStatement.close()
    END FUNCTION

LOAD DEPARTMENTS:

    FUNCTION loadDepartments():
        departments ← empty List
        sql ← "SELECT * FROM departments"

        resultSet ← statement.executeQuery(sql)

        WHILE resultSet.hasNext() DO
            dept ← new Department(
                resultSet.getString("id"),
                resultSet.getString("name"),
                resultSet.getString("region"),
                resultSet.getDouble("budget"),
                resultSet.getString("manager_id"),
                resultSet.getInt("employee_count")
            )
            departments.add(dept)
        END WHILE

        RETURN departments
    END FUNCTION

================================================================================
7. TRANSACTION MANAGEMENT
================================================================================

ALGORITHM: SaveAllEmployees(employeeList)

  PSEUDOCODE:

    FUNCTION saveAllEmployees(employeeList):
        TRY
            // Begin transaction
            connection.setAutoCommit(false)

            FOR EACH employee IN employeeList DO
                CALL saveEmployee(employee)
            END FOR

            // Commit all changes
            connection.commit()
            PRINT "✓ All employees saved successfully"

        CATCH SQLException
            // Rollback on error
            connection.rollback()
            PRINT "ERROR: Transaction failed, changes rolled back"

        FINALLY
            // Restore auto-commit
            connection.setAutoCommit(true)
        END TRY
    END FUNCTION

  ACID PROPERTIES:
    - Atomicity: All or nothing
    - Consistency: Database always in valid state
    - Isolation: Concurrent operations don't interfere
    - Durability: Committed changes persist

================================================================================
8. CONNECTION MANAGEMENT
================================================================================

CLOSE DATABASE:

    FUNCTION close():
        TRY
            IF connection IS NOT null AND NOT connection.isClosed() THEN
                connection.close()
                PRINT "✓ Database connection closed"
            END IF
        CATCH SQLException
            PRINT "ERROR: Failed to close database connection"
        END TRY
    END FUNCTION

BEST PRACTICES:
  - Always close connections in finally block
  - Use try-with-resources when possible
  - Close in reverse order: ResultSet → Statement → Connection
  - One connection per application session

================================================================================
9. ERROR HANDLING STRATEGIES
================================================================================

CONSTRAINT VIOLATIONS:

    TRY
        preparedStatement.executeUpdate()
    CATCH SQLIntegrityConstraintViolationException
        PRINT "ERROR: Duplicate ID or foreign key violation"
        // Handle gracefully - show user-friendly message
    END TRY

TIMEOUT HANDLING:

    connection.setQueryTimeout(30)  // 30 seconds

CONNECTION POOLING (Advanced):

    - Reuse connections
    - Avoid repeated connect/disconnect overhead
    - Better performance for web applications

================================================================================
10. PERFORMANCE OPTIMIZATION
================================================================================

BATCH OPERATIONS:

    FUNCTION saveMultipleEmployees(employeeList):
        preparedStatement ← connection.prepareStatement(insertSQL)

        FOR EACH employee IN employeeList DO
            // Set parameters
            preparedStatement.setString(1, employee.getId())
            ...
            // Add to batch
            preparedStatement.addBatch()
        END FOR

        // Execute all at once
        preparedStatement.executeBatch()
    END FUNCTION

  Performance gain: 10-100x faster than individual inserts

INDEXING:

    CREATE INDEX idx_employee_dept ON employees(department_id)

  Speeds up searches by department

================================================================================
                           END OF PSEUDOCODE
================================================================================
